name: Cleanup GitHub Pages queue
on:
  workflow_dispatch: {}

permissions:
  actions: write
  contents: read
  pages: write

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Cancel queued/in_progress runs of Pages workflow
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo?.owner ? context.repo : (() => {
              const [o,r] = (process.env.GITHUB_REPOSITORY||'').split('/');
              return { owner:o, repo:r };
            })();
            if (!owner || !repo) core.setFailed('owner/repo undefined');

            // znajdź workflow zawierający pages deploy (zmień jeśli używasz innej nazwy)
            const workflows = await github.paginate(github.rest.actions.listRepoWorkflows, { owner, repo, per_page:100 });
            const pagesWf = workflows.find(w =>
              w.path.endsWith('/pages.yml') ||
              /deploy.*pages/i.test(w.name||'') ||
              /pages/i.test(w.name||'')
            );
            if (!pagesWf) {
              core.notice('Nie znaleziono workflowu Pages (pages.yml) – pomijam runs.');
            } else {
              for (const status of ['queued','in_progress']) {
                for await (const resp of github.paginate.iterator(
                  github.rest.actions.listWorkflowRuns,
                  { owner, repo, workflow_id: pagesWf.id, status, per_page: 100 }
                )) {
                  const runs = resp.data?.workflow_runs || [];
                  for (const run of runs) {
                    core.info(`Cancel run ${run.id} (${status})`);
                    await github.rest.actions.cancelWorkflowRun({ owner, repo, run_id: run.id });
                    await new Promise(r => setTimeout(r, 150));
                  }
                }
              }
              // usuń zakończone runy tego samego workflowu
              for await (const resp of github.paginate.iterator(
                github.rest.actions.listWorkflowRuns,
                { owner, repo, workflow_id: pagesWf.id, status: 'completed', per_page: 100 }
              )) {
                const runs = resp.data?.workflow_runs || [];
                for (const run of runs) {
                  core.info(`Delete completed run ${run.id}`);
                  await github.rest.actions.deleteWorkflowRun({ owner, repo, run_id: run.id });
                  await new Promise(r => setTimeout(r, 100));
                }
              }
            }

      - name: Cancel active GitHub Pages deployments
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo?.owner ? context.repo : (() => {
              const [o,r] = (process.env.GITHUB_REPOSITORY||'').split('/');
              return { owner:o, repo:r };
            })();
            if (!owner || !repo) core.setFailed('owner/repo undefined');

            // API Pages deployments (wymaga pages:write)
            for await (const resp of github.paginate.iterator(
              github.request, 'GET /repos/{owner}/{repo}/pages/deployments',
              { owner, repo, per_page: 100 }
            )) {
              const list = Array.isArray(resp.data) ? resp.data : (resp.data?.deployments || []);
              for (const d of list) {
                try {
                  core.info(`Cancel Pages deployment ${d.id} (${d.status})`);
                  await github.request('POST /repos/{owner}/{repo}/pages/deployments/{deployment_id}/cancel', {
                    owner, repo, deployment_id: d.id
                  });
                  await new Promise(r => setTimeout(r, 150));
                } catch (e) {
                  core.warning(`Cancel failed ${d?.id}: ${e.message}`);
                }
              }
            }
